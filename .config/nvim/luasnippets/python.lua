return {
  -- https://github.com/defund/coppersmith/blob/master/coppersmith.sage
  s("|defund", {
    i(0),
    t({
      "import itertools",
      "",
      "",
      "def small_roots(f, bounds, m=1, d=None):",
      "    if not d:",
      "        d = f.degree()",
      "",
      "    R = f.base_ring()",
      "    N = R.cardinality()",
      "",
      "    f /= f.coefficients().pop(0)",
      "    f = f.change_ring(ZZ)",
      "",
      "    G = Sequence([], f.parent())",
      "    for i in range(m + 1):",
      "        base = N ^ (m - i) * f ^ i",
      "        for shifts in itertools.product(range(d), repeat=f.nvariables()):",
      "            g = base * prod(map(power, f.variables(), shifts))",
      "            G.append(g)",
      "",
      "    B, monomials = G.coefficient_matrix()",
      "    monomials = vector(monomials)",
      "",
      "    factors = [monomial(*bounds) for monomial in monomials]",
      "    for i, factor in enumerate(factors):",
      "        B.rescale_col(i, factor)",
      "",
      "    B = B.dense_matrix().LLL()",
      "",
      "    B = B.change_ring(QQ)",
      "    for i, factor in enumerate(factors):",
      "        B.rescale_col(i, 1 / factor)",
      "",
      "    H = Sequence([], f.parent().change_ring(QQ))",
      "    for h in filter(None, B * monomials):",
      "        H.append(h)",
      "        I = H.ideal()",
      "        if I.dimension() == -1:",
      "            H.pop()",
      "        elif I.dimension() == 0:",
      "            roots = []",
      "            for root in I.variety(ring=ZZ):",
      "                root = tuple(R(root[var]) for var in f.variables())",
      "                roots.append(root)",
      "            return roots",
      "",
      "    return []",
    }),
  }),
  -- https://github.com/rkm0959/Inequality_Solving_with_CVP/blob/main/solver.sage
  s("|rkm", {
    i(0),
    t({
      'from sage.modules.free_module_integer import IntegerLattice',
      '',
      '',
      '# Directly taken from rbtree\'s LLL repository',
      '# From https://oddcoder.com/LOL-34c3/, https://hackmd.io/@hakatashi/B1OM7HFVI',
      'def Babai_CVP(mat, target):',
      '    M = IntegerLattice(mat, lll_reduce=True).reduced_basis',
      '    G = M.gram_schmidt()[0]',
      '    diff = target',
      '    for i in reversed(range(G.nrows())):',
      '        diff -= M[i] * ((diff * G[i]) / (G[i] * G[i])).round()',
      '    return target - diff',
      '',
      '',
      'def solve(mat, lb, ub, weight=None):',
      '    num_var = mat.nrows()',
      '    num_ineq = mat.ncols()',
      '',
      '    max_element = 0',
      '    for i in range(num_var):',
      '        for j in range(num_ineq):',
      '            max_element = max(max_element, abs(mat[i, j]))',
      '',
      '    if weight == None:',
      '        weight = num_ineq * max_element',
      '',
      '        # sanity checker',
      '    if len(lb) != num_ineq:',
      '        print("Fail: len(lb) != num_ineq")',
      '        return',
      '',
      '    if len(ub) != num_ineq:',
      '        print("Fail: len(ub) != num_ineq")',
      '        return',
      '',
      '    for i in range(num_ineq):',
      '        if lb[i] > ub[i]:',
      '            print("Fail: lb[i] > ub[i] at index", i)',
      '            return',
      '',
      '            # heuristic for number of solutions',
      '    DET = 0',
      '',
      '    if num_var == num_ineq:',
      '        DET = abs(mat.det())',
      '        num_sol = 1',
      '        for i in range(num_ineq):',
      '            num_sol *= ub[i] - lb[i]',
      '        if DET == 0:',
      '            print("Zero Determinant")',
      '        else:',
      '            num_sol //= DET',
      '            # + 1 added in for the sake of not making it zero...',
      '            print("Expected Number of Solutions : ", num_sol + 1)',
      '',
      '    # scaling process begins',
      '    max_diff = max([ub[i] - lb[i] for i in range(num_ineq)])',
      '    applied_weights = []',
      '',
      '    for i in range(num_ineq):',
      '        ineq_weight = weight if lb[i] == ub[i] else max_diff // (ub[i] - lb[i])',
      '        applied_weights.append(ineq_weight)',
      '        for j in range(num_var):',
      '            mat[j, i] *= ineq_weight',
      '        lb[i] *= ineq_weight',
      '        ub[i] *= ineq_weight',
      '',
      '    # Solve CVP',
      '    target = vector([(lb[i] + ub[i]) // 2 for i in range(num_ineq)])',
      '    result = Babai_CVP(mat, target)',
      '',
      '    for i in range(num_ineq):',
      '        if (lb[i] <= result[i] <= ub[i]) == False:',
      '            print("Fail : inequality does not hold after solving")',
      '            break',
      '',
      '            # recover x',
      '    fin = None',
      '',
      '    if DET != 0:',
      '        mat = mat.transpose()',
      '        fin = mat.solve_right(result)',
      '',
      '    ## recover your result',
      '    return result, applied_weights, fin',
    }),
  }),
}, {
  s("autotrig", t("autoloaded!"))
}
